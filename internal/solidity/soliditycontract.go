package solidity

import (
	"bytes"
	"encoding/json"
	"fmt"
	"gscanner/internal/util"
	"io/ioutil"
	"strconv"
	"strings"

	"github.com/Notation/solc-go"
)

type SourceMapping struct {
	FileID  int
	Offset  int
	Length  int
	LineNum int
	Mapping string
}

type SolidityFile struct {
	FileName            string
	Data                string
	FullContractSrcMaps map[string]struct{}
}

type SourceCodeInfo struct {
	FileName    string
	LineNum     int
	Code        string
	SolcMapping string
}

func GetConstractsFromFile(file string) ([]*SolidityContract, error) {
	solcOutput, err := GetSolcJson(file)
	if err != nil {
		return nil, err
	}
	if len(solcOutput.Errors) != 0 {
		var buf bytes.Buffer
		for i := range solcOutput.Errors {
			if solcOutput.Errors[i].Type != "Error" {
				continue
			}
			buf.WriteString(solcOutput.Errors[i].FormattedMessage)
			buf.WriteString("\n")
		}
		if buf.String() != "" {
			return nil, fmt.Errorf(buf.String())
		}
	}
	if len(solcOutput.Contracts) == 0 {
		return nil, fmt.Errorf("no contract found")
	}
	result := make([]*SolidityContract, 0, len(solcOutput.Contracts))
	for contractName := range solcOutput.Contracts[file] {
		solidityContract, err := NewSolidityContract(file, contractName)
		if err != nil {
			return nil, err
		}
		result = append(result, solidityContract)
	}
	return result, nil
}

type SolidityContract struct {
	*EVMContract

	solcJSON            *solc.Output
	inputFile           string
	indices             map[int]*SolidityFile
	mappings            []*SourceMapping
	constructorMappings []*SourceMapping
}

func NewSolidityContract(inputFile string, contractName string) (*SolidityContract, error) {
	solcOutput, err := GetSolcJson(inputFile)
	if err != nil {
		return nil, err
	}

	var (
		name            string
		code            string
		creationCode    string
		srcMap          []string
		srcMapConstruct []string
		hasContract     bool
	)

	// 指定了合约名称，就根据合约名称找到对应的bytecode
	if contractName != "" {
		contract, ok := solcOutput.Contracts[inputFile][contractName]
		if ok && contract.EVM.DeployedBytecode.Object != "" {
			name = contractName
			code = contract.EVM.DeployedBytecode.Object
			srcMap = strings.Split(contract.EVM.DeployedBytecode.SourceMap, ";")
			creationCode = contract.EVM.Bytecode.Object
			srcMapConstruct = strings.Split(contract.EVM.Bytecode.SourceMap, ";")
			hasContract = true
		}
	} else {
		// 这里覆盖没问题？
		for cname, contract := range solcOutput.Contracts[inputFile] {
			if contract.EVM.DeployedBytecode.Object != "" {
				name = cname
				code = contract.EVM.DeployedBytecode.Object
				srcMap = strings.Split(contract.EVM.DeployedBytecode.SourceMap, ";")
				creationCode = contract.EVM.Bytecode.Object
				srcMapConstruct = strings.Split(contract.EVM.Bytecode.SourceMap, ";")
				hasContract = true
			}
		}
	}
	if !hasContract {
		return nil, fmt.Errorf("no contract found")
	}

	indices, err := getSolcIndices(solcOutput)
	if err != nil {
		return nil, err
	}

	s := &SolidityContract{
		EVMContract: NewEVMContract(code, creationCode, name),
		inputFile:   inputFile,
		solcJSON:    solcOutput,
		indices:     indices,
	}
	s.mappings = s.getSolcMappings(srcMap)
	s.constructorMappings = s.getSolcMappings(srcMapConstruct)
	return s, nil
}

func (sc *SolidityContract) isAutogeneratedCode(offset, length, fileIndex int) bool {
	if fileIndex == -1 {
		return true
	}
	k := fmt.Sprintf("%d:%d:%d", offset, length, fileIndex)
	if _, ok := sc.indices[fileIndex].FullContractSrcMaps[k]; ok {
		return true
	}
	return false
}

func (sc *SolidityContract) getSolcMappings(srcMap []string) []*SourceMapping {
	var (
		prevItem string
		mappings []*SourceMapping
	)
	for _, item := range srcMap {
		if item == "" {
			item = prevItem
		}
		var (
			err                         error
			offset, length, idx, lineno int
		)
		mapping := strings.Split(item, ":")
		if len(mapping) > 0 && mapping[0] != "" {
			offset, err = strconv.Atoi(mapping[0])
			if err != nil {
				fmt.Printf("offset atoi %s -> %v\n", mapping[0], err)
			}
		}
		if len(mapping) > 1 && mapping[1] != "" {
			length, err = strconv.Atoi(mapping[1])
			if err != nil {
				fmt.Printf("length atoi  %s -> %v\n", mapping[1], err)
			}
		}
		if len(mapping) > 2 && mapping[2] != "" {
			idx, err = strconv.Atoi(mapping[2])
			if err != nil {
				fmt.Printf("idx atoi %s -> %v\n", mapping[2], err)
			}
		}
		if sc.isAutogeneratedCode(offset, length, idx) {
			lineno = 0
		} else {
			lineno = strings.Count(sc.indices[idx].Data[0:offset], "\n") + 1
		}
		prevItem = item
		mappings = append(mappings, &SourceMapping{
			FileID:  idx,
			Offset:  offset,
			Length:  length,
			LineNum: lineno,
			Mapping: item,
		})
	}
	return mappings
}

func (sc *SolidityContract) GetSourceInfo(address int, constructor bool) *SourceCodeInfo {
	var (
		disassembly = sc.Disassembly
		mappings    = sc.mappings
	)
	if constructor {
		disassembly = sc.CreationDisassembly
		mappings = sc.constructorMappings
	}

	index := util.GetInstructionIndex(disassembly.GetInstructions(), address)
	sourceMapping := mappings[index]
	if sourceMapping.FileID == -1 {
		return nil
	}
	solidityFile := sc.indices[sourceMapping.FileID]
	return &SourceCodeInfo{
		FileName:    solidityFile.FileName,
		LineNum:     sourceMapping.LineNum,
		Code:        solidityFile.Data[sourceMapping.Offset : sourceMapping.Offset+sourceMapping.Length],
		SolcMapping: sourceMapping.Mapping,
	}
}

func getSolcIndices(solcOut *solc.Output) (map[int]*SolidityFile, error) {
	// skipped generatedSources
	// ["evm"]["bytecode"]["generatedSources"]
	// ["evm"]["deployedBytecode"]["generatedSources"]
	indices := make(map[int]*SolidityFile)
	for _, source := range solcOut.Sources {
		m, file := getFullContractSrcMaps(&source)
		codeData, err := ioutil.ReadFile(file)
		if err != nil {
			return nil, err
		}
		indices[source.ID] = &SolidityFile{
			FileName:            file,
			Data:                string(codeData),
			FullContractSrcMaps: m,
		}
	}

	return indices, nil
}

type AST struct {
	AbsolutePath string    `json:"absolutePath"`
	NodeType     string    `json:"nodeType"`
	Nodes        []ASTNode `json:"nodes"`
}

type ASTNode struct {
	NodeType     string `json:"nodeType"`
	ContractKind string `json:"contractKind"`
	Statements   string `json:"statements"`
	Src          string `json:"src"`
}

func getFullContractSrcMaps(source *solc.SourceOut) (map[string]struct{}, string) {
	var (
		m   = make(map[string]struct{})
		ast AST
	)
	err := json.Unmarshal(source.AST, &ast)
	if err != nil {
		fmt.Println(err)
	}
	if ast.NodeType == "SourceUnit" {
		for _, node := range ast.Nodes {
			if node.ContractKind != "" {
				m[node.Src] = struct{}{}
			}
		}
		return m, ast.AbsolutePath
	}
	if ast.NodeType == "YulBlock" {
		for _, node := range ast.Nodes {
			if node.Statements != "" {
				m[node.Src] = struct{}{}
			}
		}
		return m, ast.AbsolutePath
	}
	return m, ast.AbsolutePath
}
